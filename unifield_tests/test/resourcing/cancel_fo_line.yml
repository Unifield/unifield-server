-
  In order to test the cancelation and re-sourcing of a FO line, we will create
  a FO with three FO lines and cancel them one after the other
-
  FO which contains FO lines to cancel
-
  !record {model: sale.order, id: cancel_fol_fo1}:
    partner_order_id: test_partner1_address
    partner_invoice_id: test_partner1_address
    partner_shipping_id: test_partner1_address
    partner_id: test_partner1
    pricelist_id: purchase.list0
    order_type: regular
-
  First FO line to cancel
-
  !record {model: sale.order.line, id: cancel_fol_fo1_l1}:
    order_id: cancel_fol_fo1
    product_uom: product.product_uom_unit
    product_id: test_product1
    price_unit: 1.50
    product_uom_qty: 10
    name: Product 1
-
  Second FO line to cancel
-
  !record {model: sale.order.line, id: cancel_fol_fo1_l2}:
    order_id: cancel_fol_fo1
    product_uom: product.product_uom_unit
    product_id: test_product2
    price_unit: 1.50
    product_uom_qty: 30
    name: Product 2
-
  Third FO line to cancel
-
  !record {model: sale.order.line, id: cancel_fol_fo1_l3}:
    order_id: cancel_fol_fo1
    product_uom: product.product_uom_unit
    product_id: test_product3
    price_unit: 1.50
    product_uom_qty: 100
    name: Product 3
-
  Fourth FO line to cancel
-
  !record {model: sale.order.line, id: cancel_fol_fo1_l4}:
    order_id: cancel_fol_fo1
    product_uom: product.product_uom_unit
    product_id: test_product4
    price_unit: 1.50
    product_uom_qty: 100
    name: Product 4
-
  Fifth FO line to cancel
-
  !record {model: sale.order.line, id: cancel_fol_fo1_l5}:
    order_id: cancel_fol_fo1
    product_uom: product.product_uom_unit
    product_id: test_product5
    price_unit: 1.50
    product_uom_qty: 100
    name: Product 5
-
  Validate the FO
-
  !workflow {model: sale.order, action: order_validated, ref: cancel_fol_fo1}
-
  We are trying to cancel the first FO line, a wizard should be displayed
  to ask user if he wants to re-source this line in a new FO
-
  !python {model: sale.order.line}: |
    import logging
    # Objects
    order_obj = self.pool.get('sale.order')
    l_wiz_obj = self.pool.get('sale.order.line.unlink.wizard')
    o_wiz_obj = self.pool.get('sale.order.unlink.wizard')
    logger = logging.getLogger('tests')

    # Object instances
    cancel_fol_fo1 = order_obj.browse(cr, uid, ref('cancel_fol_fo1'), context=context)

    # Variables
    first_created_fo_name = ''

    ## Tests
    # Ask unlink of FO line => Must return a wizard
    logger.log(logging.TEST, "Unlink the first FO line")
    res = self.ask_unlink(cr, uid, ref('cancel_fol_fo1_l1'), context=context)
    assert isinstance(res, dict), "Cancel FO line doesn't return a dict"
    wiz_id = res.get('res_id', False)
    assert wiz_id, "Cancel FO line doesn't return a valid wizard"
    # Cancel the FO line without resourcing
    res = l_wiz_obj.cancel_fo_line(cr, uid, wiz_id, context=context)
    assert res.get('type') in ('ir.actions.act_window', 'ir.actions.act_window_close'), "Cancel w/o re-sourcing the line doesn't close the wizard window"
    # Check if the FO line is removed
    line_ids = self.search(cr, uid, [('id', '=', ref('cancel_fol_fo1_l1'))], context=context)
    assert not line_ids, "The first FO line has not been removed"

    # Cancel the FO line with re-source it
    # Ask unlink of FO line => Must return a wizard
    logger.log(logging.TEST, "Unlink the second FO line")
    res = self.ask_unlink(cr, uid, ref('cancel_fol_fo1_l2'), context=context)
    assert isinstance(res, dict), "Cancel FO line doesn't return a dict"
    wiz_id = res.get('res_id', False)
    assert wiz_id, "Cancel FO line doesn't return a valid wizard"
    # Cancel the FO line with re-sourcing of the line
    res = l_wiz_obj.resource_line(cr, uid, wiz_id, context=context)
    assert res.get('type') in ('ir.actions.act_window', 'ir.actions.act_window_close'), "#1 - Cancel FO line with re-sourcing the line doesn't close the wizard window"
    # Check if the FO line is removed
    line_ids = self.search(cr, uid, [('id', '=', ref('cancel_fol_fo1_l2'))], context=context)
    assert not line_ids, "The second FO line has not been removed"
    # Check if the line is re-sourced
    new_fo_ids = order_obj.search(cr, uid, [('fo_to_resource', '=', True), ('parent_order_name', '=', cancel_fol_fo1.name)], context=context)
    new_line_ids = self.search(cr, uid, [('order_id', 'in', new_fo_ids), ('product_id', '=', ref('test_product2'))], context=context)
    assert new_line_ids, "#1 Cancel FO line with re-sourcing the line doesn't create new FO line"
    new_lines = self.browse(cr, uid, new_line_ids, context=context)
    for l in new_lines:
        assert l.order_id, "Cancel FO line with re-sourcing the line doesn't create a new FO"
        first_created_fo_name = l.order_id.name

    # Ask unlink of FO line => Must return a wizard
    logger.log(logging.TEST, "Unlink the third FO line")
    res = self.ask_unlink(cr, uid, ref('cancel_fol_fo1_l3'), context=context)
    assert isinstance(res, dict), "Cancel FO line doesn't return a dict"
    wiz_id = res.get('res_id', False)
    assert wiz_id, "Cancel FO line doesn't return a valid wizard"
    # Cancel the FO line with re-sourcing of the line
    res = l_wiz_obj.resource_line(cr, uid, wiz_id, context=context)
    assert res.get('type') in ('ir.actions.act_window', 'ir.actions.act_window_close'), "#2 - Cancel FO line with re-sourcing the line doesn't close the wizard window"
    # Check if the FO line is removed
    line_ids = self.search(cr, uid, [('id', '=', ref('cancel_fol_fo1_l3'))], context=context)
    assert not line_ids, "The third FO line has not been removed"
    # Check if the line is re-sourced in the same FO as the last line
    new_fo_ids = order_obj.search(cr, uid, [('fo_to_resource', '=', True), ('parent_order_name', '=', cancel_fol_fo1.name)], context=context)
    new_line_ids = self.search(cr, uid, [('order_id', 'in', new_fo_ids), ('product_id', '=', ref('test_product3'))], context=context)
    assert new_line_ids, "#2 Cancel FO line with re-sourcing the line doesn't create new FO line"
    new_lines = self.browse(cr, uid, new_line_ids, context=context)
    for l in new_lines:
        assert l.order_id, "Cancel FO line with re-sourcing the line doesn't create a new FO"
        assert l.order_id.name == first_created_fo_name, "The cancelation and re-sourcing of a second line of a FO doesn't create a new FO line in the same FO than the first re-sourced line"

        # Validate the FO that re-sourced the initial one
        import netsvc
        wf_service = netsvc.LocalService('workflow')
        wf_service.trg_validate(uid, 'sale.order', l.order_id.id, 'order_validated', cr)

    # Ask unlink of FO line => Must return a wizard
    logger.log(logging.TEST, "Unlink the fourth FO line")
    res = self.ask_unlink(cr, uid, ref('cancel_fol_fo1_l4'), context=context)
    assert isinstance(res, dict), "Cancel FO line doesn't return a dict"
    wiz_id = res.get('res_id', False)
    assert wiz_id, "Cancel FO line doesn't return a valid wizard"
    # Cancel the FO line with re-sourcing of the line
    res = l_wiz_obj.resource_line(cr, uid, wiz_id, context=context)
    assert res.get('type') in ('ir.actions.act_window', 'ir.actions.act_window_close'), "#3 - Cancel FO line with re-sourcing the line doesn't close the wizard window"
    # Check if the FO line is removed
    line_ids = self.search(cr, uid, [('id', '=', ref('cancel_fol_fo1_l4'))], context=context)
    assert not line_ids, "The fourth FO line has not been removed"
    # Check if the line is re-sourced in another FO than the two last lines
    new_fo_ids = order_obj.search(cr, uid, [('fo_to_resource', '=', True), ('parent_order_name', '=', cancel_fol_fo1.name)], context=context)
    new_line_ids = self.search(cr, uid, [('order_id', 'in', new_fo_ids), ('product_id', '=', ref('test_product4'))], context=context)
    assert new_line_ids, "#3 Cancel FO line with re-sourcing the line doesn't create new FO line"
    new_lines = self.browse(cr, uid, new_line_ids, context=context)
    for l in new_lines:
        assert l.order_id, "Cancel FO line with re-sourcing the line doesn't create a new FO"
        assert l.order_id.name != first_created_fo_name, "The cancelation and re-sourcing of a third line of a FO doesn't create a new FO if the last resourcirng FO is not in Draft state"

    # Ask unlink of the last line of a FO => Ask user if he wants to cancel the empty FO
    logger.log(logging.TEST, "Unlink the fifth FO line")
    res = self.ask_unlink(cr, uid, ref('cancel_fol_fo1_l5'), context=context)
    assert isinstance(res, dict), "Cancel the last FO line doesn't return a dict"
    wiz_id = res.get('res_id', False)
    assert wiz_id, "Cancel the last FO line doesn't return a valid wizard"
    res = l_wiz_obj.cancel_fo_line(cr, uid, wiz_id, context=context)
    assert res.get('res_model', False) == 'sale.order.unlink.wizard', "Cancel the last FO line doesn't ask user if he wants to cancel the empty FO"
    wiz_id = res.get('res_id', False)
    assert wiz_id, "Cancel the last FO line doesn't return a valid wizard"
    wiz = o_wiz_obj.browse(cr, uid, wiz_id, context=context)
    # Cancel the empty FO
    res = o_wiz_obj.cancel_fo(cr, uid, wiz_id, context=context)
    assert res.get('type', False) == 'ir.actions.act_window_close', "Cancel the empty FO doesn't close the wizard window"
    # Check if the FO line is removed
    line_ids = self.search(cr, uid, [('id', '=', ref('cancel_fol_fo1_l5'))], context=context)
    assert not line_ids, "The fifth FO line has not been removed"
    # Check if the FO is canceled
    initial_fo = order_obj.browse(cr, uid, ref('cancel_fol_fo1'), context=context)
    assert initial_fo.state == 'cancel', "The initial empty FO is not canceled"
