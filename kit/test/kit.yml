- 
  I create empty theoretical composition list 01, productA, ITC, 2010-01-20
- 
  !record {model: composition.kit, id: kit_compo_01}:
    composition_type: 'theoretical'
    composition_product_id: kit_product_A
    composition_version_txt: 'ITC'
    composition_creation_date: '2010-01-20'
-
  I test the function fields for kit_compo_01
-
  !python {model: composition.kit}: |
    kit = self.browse(cr, uid, ref("kit_compo_01"), context=context)
    # composition_batch_check: should be true
    assert kit.composition_batch_check, 'kit_compo_01: composition_batch_check should be true - %s'%kit.composition_batch_check
    # composition_expiry_check: should be true
    assert kit.composition_expiry_check, 'kit_compo_01: composition_expiry_check should be true - %s'%kit.composition_expiry_check
    # name: ITC - 20/jan/2010 - I believe you it is correct
    
    # composition_version: ITC
    assert kit.composition_version, 'kit_compo_01: composition_version should be %s - %s'%(kit.composition_version_txt,kit.composition_version)
    # composition_combined_ref_lot: False
    assert not kit.composition_combined_ref_lot, 'kit_compo_01: composition_combined_ref_lot should be false - %s'%kit.composition_combined_ref_lot
- 
  I create empty theoretical composition list 02, productA, OCG, 2010-01-20
- 
  !record {model: composition.kit, id: kit_compo_02}:
    composition_type: 'theoretical'
    composition_product_id: kit_product_A
    composition_version_txt: 'OCG'
    composition_creation_date: '2010-01-20'
- 
  I create empty theoretical composition list 03, productB, OCG, 2010-01-20
- 
  !record {model: composition.kit, id: kit_compo_03}:
    composition_type: 'theoretical'
    composition_product_id: kit_product_B
    composition_version_txt: 'OCG'
    composition_creation_date: '2010-01-20'
-
  I then create Items for the compo 01 - prodC
-
  !record {model: composition.item, id: item_01_01}:
    item_kit_id: kit_compo_01
    item_product_id: kit_product_C
    item_qty: 10
    item_uom_id: product.product_uom_unit
-
  I check the function fields of composition item
-
  !python {model: composition.item}: |
    item = self.browse(cr, uid, ref("item_01_01"), context=context)
    # name
    assert item.name == item.item_product_id.name, 'item_01_01: name field is wrong - %s - %s'%(item.item_product_id.name,item.name)
    # item_kit_version
    assert item.item_kit_version == item.item_kit_id.composition_version, 'item_01_01: item_kit_version field is wrong - %s - %s'%(item.item_kit_id.composition_version,item.item_kit_version)
    # item_kit_type
    assert item.item_kit_type == item.item_kit_id.composition_type, 'item_01_01: item_kit_type field is wrong - %s - %s'%(item.item_kit_id.composition_type,item.item_kit_type)
    # state
    assert item.state == item.item_kit_id.state, 'item_01_01: state field is wrong - %s - %s'%(item.item_kit_id.state,item.state)
-
  !record {model: composition.item, id: item_01_02}:
    item_kit_id: kit_compo_01
    item_product_id: kit_product_C
    item_qty: 20
    item_uom_id: product.product_uom_unit
-
  I set the theoretical kit 01 as inactive
-
  !python {model: composition.kit}: |
    self.mark_as_inactive(cr, uid, [ref("kit_compo_01")], context=context)
    kit = self.browse(cr, uid, ref("kit_compo_01"), context=context)
    assert not kit.active, 'kit_compo_01: the field active is wrong, should be false - %s'%kit.active
-
  I set the theoretical kit 01 back as active
-
  !python {model: composition.kit}: |
    self.mark_as_active(cr, uid, [ref("kit_compo_01")], context=context)
    kit = self.browse(cr, uid, ref("kit_compo_01"), context=context)
    assert kit.active, 'kit_compo_01: the field active is wrong, should be true - %s'%kit.active
-
  I set the theoretical kit 01 as complete and check corresponding states
-
  !python {model: composition.kit}: |
    self.mark_as_completed(cr, uid, [ref("kit_compo_01")], context=context)
    kit = self.browse(cr, uid, ref("kit_compo_01"), context=context)
    assert kit.state == 'completed', 'kit_compo_01: the field state is wrong, should be completed - %s'%kit.state
    
    for item in kit.composition_item_ids:
      assert item.state == 'completed', 'kit_compo_01: the field state of corresponding item is wrong, should be completed - %s'%item.state
- 
  I create sale order kit_so_A
- 
  !record {model: sale.order, id: kit_so_A}:
    name: so a
    amount_tax: 0.0
    amount_total: 1.0
    amount_untaxed: 1.0
    company_id: base.main_company
    date_order: '2011-04-13'
    invoice_quantity: order
    order_policy: manual
    partner_id: kit_partner_A
    partner_invoice_id: kit_address_A
    partner_order_id: kit_address_A
    partner_shipping_id: kit_address_A
    picking_policy: direct
    pricelist_id: product.list0
    shop_id: sale.shop
    priority: normal
    categ: medical
- 
  I create a corresponding sale order line, with a batch management kit in it - prodA
- 
  !record {model: sale.order.line, id: kit_sol_A1}:
    name: sol a1
    company_id: base.main_company
    delay: 7.0
    order_id: kit_so_A
    price_unit: 1.0
    product_id: kit_product_A
    product_uom: product.product_uom_unit
    product_uom_qty: 10
    salesman_id: base.user_admin
    state: draft
    th_weight: 0.0
    type: make_to_order
-
  I validate kit_sol_A1
-
  !python {model: sale.order}: |
    import netsvc
    wf_service = netsvc.LocalService("workflow")
    wf_service.trg_validate(uid, 'sale.order', ref("kit_so_A"), 'order_validated', cr)
    wf_service.trg_validate(uid, 'sale.order', ref("kit_so_A"), 'order_confirm', cr)
-
  I run the scheduler
-
  !python {model: procurement.order}: |
    self.run_scheduler(cr, uid, context=context)
-
  I check the corresponding purchase order has been created and store the corresponding id in the context
-
  !python {model: purchase.order}: |
    ids = self.search(cr, uid, [('origin', '=', 'so a')], context=context)
    assert len(ids) == 1, 'the number of created purchase order is wrong - 1 - %s'%len(ids)
    context.setdefault('yml_kit', {}).update(po=ids[0])
-
  I validate the purchase order (2 steps)
-
  !python {model: purchase.order}: |
    import netsvc
    po_id = context['yml_kit']['po']
    wf_service = netsvc.LocalService("workflow")
    wf_service.trg_validate(uid, 'purchase.order', po_id, 'purchase_confirm', cr)
    wf_service.trg_validate(uid, 'purchase.order', po_id, 'purchase_approve', cr)
-
  I check the corresponding incoming shipment has been created and store the corresponding id in the context
-
  !python {model: stock.picking}: |
    po_id = context['yml_kit']['po']
    ids = self.search(cr, uid, [('purchase_id', '=', po_id)], context=context)
    assert len(ids) == 1, 'the number of created incoming shipment is wrong - 1 - %s'%len(ids)
    context.setdefault('yml_kit', {}).update({'in':ids[0]})
-
  I open the process wizard of incoming shipment
-
  !python {model: stock.picking}: |
    in_id = context['yml_kit']['in']
    data = self.action_process(cr, uid, [in_id], context=context)
    context.setdefault('yml_kit', {}).setdefault('wiz', {}).update({'id': data['res_id'], 'model': data['res_model']})
    context['c'] = data['context']
    # check the picking type
    pick = self.browse(cr, uid, in_id, context=context)
    type = self.pool.get('stock.partial.picking').get_picking_type(cr, uid, pick, context=context)
    context.update({'type': type})
-
  I complete the batch number in processing wizard and validate the wizard using wizard's context
-
  !python {model: stock.partial.picking}: |
    wiz_id = context['yml_kit']['wiz']['id']
    c = context['c']
    in_id = context['yml_kit']['in']
    type = context['type']
    for mem in getattr(self.browse(cr, uid, wiz_id, context=c), 'product_moves_%s'%type):
      mem.write({'prodlot_id': ref("kit_lot_As")}, context=c)
    self.do_incoming_shipment(cr, uid, [wiz_id], context=c)
-
  Check that the incoming shipment is done
-
  !python {model: stock.picking}: |
    in_id = context['yml_kit']['in']
    pick = self.browse(cr, uid, in_id, context=context)
    assert pick.state == 'done', 'incoming shipment the state is wrong, should be done - %s'%pick.state
-
  I click on the create composition list button of the stock move which contains the kit
-
  !python {model: stock.move}: |
    in_id = context['yml_kit']['in']
    ids = self.search(cr, uid, [('picking_id', '=', in_id), ('product_id', '=', ref("kit_product_A"))], context=context)
    self.create_composition_list(cr, uid, ids, context=context)
-
  END OF FILE
-
  !python {model: stock.picking}: |
    print 'EOF'
