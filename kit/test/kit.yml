- 
  I create empty theoretical composition list 01, productA, ITC, 2010-01-20
- 
  !record {model: composition.kit, id: kit_compo_01}:
    composition_type: 'theoretical'
    composition_product_id: kit_product_A
    composition_version_txt: 'ITC'
    composition_creation_date: '2010-01-20'
-
  I test the function fields for kit_compo_01
-
  !python {model: composition.kit}: |
    kit = self.browse(cr, uid, ref("kit_compo_01"), context=context)
    # composition_batch_check: should be true
    assert kit.composition_batch_check, 'kit_compo_01: composition_batch_check should be true - %s'%kit.composition_batch_check
    # composition_expiry_check: should be true
    assert kit.composition_expiry_check, 'kit_compo_01: composition_expiry_check should be true - %s'%kit.composition_expiry_check
    # name: ITC - 20/jan/2010 - I believe you it is correct
    
    # composition_version: ITC
    assert kit.composition_version, 'kit_compo_01: composition_version should be %s - %s'%(kit.composition_version_txt,kit.composition_version)
    # composition_combined_ref_lot: False
    assert not kit.composition_combined_ref_lot, 'kit_compo_01: composition_combined_ref_lot should be false - %s'%kit.composition_combined_ref_lot
- 
  I create empty theoretical composition list 02, productA, OCG, 2010-01-20
- 
  !record {model: composition.kit, id: kit_compo_02}:
    composition_type: 'theoretical'
    composition_product_id: kit_product_A
    composition_version_txt: 'OCG'
    composition_creation_date: '2010-01-20'
- 
  I create empty theoretical composition list 03, productB, OCG, 2010-01-20
- 
  !record {model: composition.kit, id: kit_compo_03}:
    composition_type: 'theoretical'
    composition_product_id: kit_product_B
    composition_version_txt: 'OCG'
    composition_creation_date: '2010-01-20'
-
  I then create Items for the compo 01 - prodC
-
  !record {model: composition.item, id: item_01_01}:
    item_kit_id: kit_compo_01
    item_product_id: kit_product_C
    item_qty: 10
    item_uom_id: product.product_uom_unit
-
  I check the function fields of composition item
-
  !python {model: composition.item}: |
    item = self.browse(cr, uid, ref("item_01_01"), context=context)
    # name
    assert item.name == item.item_product_id.name, 'item_01_01: name field is wrong - %s - %s'%(item.item_product_id.name,item.name)
    # item_kit_version
    assert item.item_kit_version == item.item_kit_id.composition_version, 'item_01_01: item_kit_version field is wrong - %s - %s'%(item.item_kit_id.composition_version,item.item_kit_version)
    # item_kit_type
    assert item.item_kit_type == item.item_kit_id.composition_type, 'item_01_01: item_kit_type field is wrong - %s - %s'%(item.item_kit_id.composition_type,item.item_kit_type)
    # state
    assert item.state == item.item_kit_id.state, 'item_01_01: state field is wrong - %s - %s'%(item.item_kit_id.state,item.state)
-
  !record {model: composition.item, id: item_01_02}:
    item_kit_id: kit_compo_01
    item_product_id: kit_product_C
    item_qty: 20
    item_uom_id: product.product_uom_unit
-
  I set the theoretical kit 01 as inactive
-
  !python {model: composition.kit}: |
    self.mark_as_inactive(cr, uid, [ref("kit_compo_01")], context=context)
    kit = self.browse(cr, uid, ref("kit_compo_01"), context=context)
    assert not kit.active, 'kit_compo_01: the field active is wrong, should be false - %s'%kit.active
-
  I set the theoretical kit 01 back as active
-
  !python {model: composition.kit}: |
    self.mark_as_active(cr, uid, [ref("kit_compo_01")], context=context)
    kit = self.browse(cr, uid, ref("kit_compo_01"), context=context)
    assert kit.active, 'kit_compo_01: the field active is wrong, should be true - %s'%kit.active
-
  I set the theoretical kit 01 as complete and check corresponding states
-
  !python {model: composition.kit}: |
    self.mark_as_completed(cr, uid, [ref("kit_compo_01")], context=context)
    kit = self.browse(cr, uid, ref("kit_compo_01"), context=context)
    assert kit.state == 'completed', 'kit_compo_01: the field state is wrong, should be completed - %s'%kit.state
    
    for item in kit.composition_item_ids:
      assert item.state == 'completed', 'kit_compo_01: the field state of corresponding item is wrong, should be completed - %s'%item.state
- 
  I create sale order kit_so_A
- 
  !record {model: sale.order, id: kit_so_A}:
    name: so a
    amount_tax: 0.0
    amount_total: 1.0
    amount_untaxed: 1.0
    company_id: base.main_company
    date_order: '2011-04-13'
    invoice_quantity: order
    order_policy: manual
    partner_id: kit_partner_A
    partner_invoice_id: kit_address_A
    partner_order_id: kit_address_A
    partner_shipping_id: kit_address_A
    picking_policy: direct
    pricelist_id: product.list0
    shop_id: sale.shop
    priority: normal
    categ: medical
- 
  I create a corresponding sale order line, with a batch management kit in it - prodA
- 
  !record {model: sale.order.line, id: kit_sol_A1}:
    name: sol a1
    company_id: base.main_company
    delay: 7.0
    order_id: kit_so_A
    price_unit: 1.0
    product_id: kit_product_A
    product_uom: product.product_uom_unit
    product_uom_qty: 10
    salesman_id: base.user_admin
    state: draft
    th_weight: 0.0
    type: make_to_order
-
  I validate kit_sol_A1
-
  !python {model: sale.order}: |
    import netsvc
    wf_service = netsvc.LocalService("workflow")
    wf_service.trg_validate(uid, 'sale.order', ref("kit_so_A"), 'order_validated', cr)
    wf_service.trg_validate(uid, 'sale.order', ref("kit_so_A"), 'order_confirm', cr)
-
  I run the scheduler
-
  !python {model: procurement.order}: |
    self.run_scheduler(cr, uid, context=context)
-
  I check the corresponding purchase order has been created and store the corresponding id in the context
-
  !python {model: purchase.order}: |
    ids = self.search(cr, uid, [('origin', '=', 'so a')], context=context)
    assert len(ids) == 1, 'the number of created purchase order is wrong - 1 - %s'%len(ids)
    context.setdefault('yml_kit', {}).update(po=ids[0])
-
  I validate the purchase order (2 steps)
-
  !python {model: purchase.order}: |
    import netsvc
    po_id = context['yml_kit']['po']
    wf_service = netsvc.LocalService("workflow")
    wf_service.trg_validate(uid, 'purchase.order', po_id, 'purchase_confirm', cr)
    wf_service.trg_validate(uid, 'purchase.order', po_id, 'purchase_approve', cr)
-
  I check the corresponding incoming shipment has been created and store the corresponding id in the context
-
  !python {model: stock.picking}: |
    po_id = context['yml_kit']['po']
    ids = self.search(cr, uid, [('purchase_id', '=', po_id)], context=context)
    assert len(ids) == 1, 'the number of created incoming shipment is wrong - 1 - %s'%len(ids)
    context.setdefault('yml_kit', {}).update({'in':ids[0]})
-
  I open the process wizard of incoming shipment
-
  !python {model: stock.picking}: |
    in_id = context['yml_kit']['in']
    data = self.action_process(cr, uid, [in_id], context=context)
    context.setdefault('yml_kit', {}).setdefault('wiz', {}).update({'id': data['res_id'], 'model': data['res_model']})
    context['c'] = data['context']
    # check the picking type
    pick = self.browse(cr, uid, in_id, context=context)
    type = self.pool.get('stock.partial.picking').get_picking_type(cr, uid, pick, context=context)
    context.update({'type': type})
-
  I complete the batch number in processing wizard and validate the wizard using wizard's context
-
  !python {model: stock.partial.picking}: |
    wiz_id = context['yml_kit']['wiz']['id']
    c = context['c']
    in_id = context['yml_kit']['in']
    type = context['type']
    for mem in getattr(self.browse(cr, uid, wiz_id, context=c), 'product_moves_%s'%type):
      mem.write({'prodlot_id': ref("kit_lot_As")}, context=c)
    self.do_incoming_shipment(cr, uid, [wiz_id], context=c)
-
  Check that the incoming shipment is done
-
  !python {model: stock.picking}: |
    in_id = context['yml_kit']['in']
    pick = self.browse(cr, uid, in_id, context=context)
    assert pick.state == 'done', 'incoming shipment the state is wrong, should be done - %s'%pick.state
-
  I click on the create composition list button of the stock move which contains the kit
-
  !python {model: stock.move}: |
    in_id = context['yml_kit']['in']
    ids = self.search(cr, uid, [('picking_id', '=', in_id), ('product_id', '=', ref("kit_product_A"))], context=context)
    self.create_composition_list(cr, uid, ids, context=context)
-
  I create empty composition composition list 04, productA, kit_lot_As, 2010-01-20
- 
  !record {model: composition.kit, id: kit_compo_04}:
    composition_type: 'real'
    composition_product_id: kit_product_A
    composition_lot_id: kit_lot_As
    composition_creation_date: '2010-01-20'
    composition_version_id: kit_compo_02
-
  I add a product item to the composition list kit_product_C, lot and date will be filled in in the wizard
-
  !record {model: composition.item, id: item_04_01}:
    item_kit_id: kit_compo_04
    item_product_id: kit_product_C
    item_qty: 20
    item_uom_id: product.product_uom_unit
-
  Mark the composition as completed
-
  !python {model: composition.kit}: |
    self.mark_as_completed(cr, uid, [ref("kit_compo_04")], context=context)
-
  I open the substitute wizard
-
  !python {model: composition.kit}: |
    res = self.substitute_items(cr, uid, [ref("kit_compo_04")], context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I complete the lot name for the product C
-
  !python {model: substitute.item.mirror}: |
    item_ids = self.search(cr, uid, [('wizard_id', '=', context['wizard']['id'])], context=context)
    assert len(item_ids) == 1, 'number of items is wrong - 1 - %s'%len(item_ids)
    self.write(cr, uid, item_ids, {'lot_mirror': 'C standard', 'exp_substitute_item': '2012-06-20'}, context=context)
    context['wizard']['item_ids'] = item_ids
-
  I test the on_change functions
-
  !python {model: substitute.item.mirror}: |
    self.change_lot(cr, uid, context['wizard']['item_ids'], ref("stock.stock_location_stock"), ref("kit_product_C"), 'C standard', ref("product.product_uom_unit"), context=context)
    self.change_expiry(cr, uid, context['wizard']['item_ids'], '2012-06-20', ref("kit_product_C"), 'in', ref("stock.stock_location_stock"), 'C standard', ref("product.product_uom_unit"), context=context)
-
  I select the item to be replaced
-
  !python {model: substitute}: |
    self.write(cr, uid, context['wizard']['ids'], {'composition_item_ids': [(6,0,context['wizard']['item_ids'])]}, context=context)
-
  I select the item for the kit from the stock
-
  !python {model: substitute.item}: |
    values = {'wizard_id': context['wizard']['id'],
              'location_id_substitute_item': ref("stock.stock_location_stock"),
              'module_substitute_item': 'module substitute',
              'product_id_substitute_item': ref("kit_product_C"),
              'qty_substitute_item': 60,
              'uom_id_substitute_item': ref("product.product_uom_unit"),
              'lot_id_substitute_item': ref("kit_lot_Cs"),
              }
    self.create(cr, uid, values, context=context)
-
  I process the subtitute function
-
  !python {model: substitute}: |
    self.do_substitute(cr, uid, context['wizard']['ids'], context=context['wizard']['c'])
-
  I open the de-kitting wizard
-
  !python {model: composition.kit}: |
    res = self.de_kitting(cr, uid, [ref("kit_compo_04")], context=context)
    model = res['res_model']
    id = res['res_id']
    c = res['context']
    context['wizard'] = {'id': id, 'ids': [id], 'model': model, 'c': c}
-
  I process the de-kitting - we do not need to complete lot or date because it is automaticly completed from the substitute function !
-
  !python {model: substitute}: |
    self.do_de_kitting(cr, uid, context['wizard']['ids'], context=context['wizard']['c'])
-
  END OF FILE
-
  !python {model: stock.picking}: |
    print 'EOF'
